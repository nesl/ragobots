/* -*- Mode: C; tab-width:4 -*- */
/* ex: set ts=4 shiftwidth=4 softtabstop=4 cindent: */
/*                                  tab:4
 * "Copyright (c) 2000-2003 The Regents of the University  of California.  
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
 *
 *
 */
/**
 * @author David Lee
 */
/**
 * @brief Provides support for the hipri_int interrupt 
 *
 * A hipri_int interrupt is generated by IRMAN or another attached processor
 * on the Nerve board when either wants to alert the Brain board of an 
 * important event.
 */

#include <ragobot_module.h>
#include <hipri_int.h>
#include <avr/signal.h>

#define MAXREGMOD  2  //the maximum number of modules that can register
#define ALERTREG_ADDRESS 0x3F //the i2c address of the alert register
#define BACKOFF_TIME 80

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// LOCAL VARIABLES
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

static uint8_t registered_modules[MAXREGMOD];
static uint8_t numRegMod; //the number of registered modules

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// LOCAL FUNCTIONS
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void hipri_int_broadcast();

static int8_t hipri_int_register(char* proto, uint8_t pid);
static int8_t hipri_int_deregister(char* proto, uint8_t pid);

/*
  Note: Alert Reset Sequence
  1) pull reset low
  2) request read
  3) read from register
  4) pull reset high
  
  step 2 and 3 are required to ensure that the interrupt line goes high
 */

enum {
  IDLE,         // idle state
  INIT,         // initialization state
  RESET_REG1,   // reset ALERT REGISTERS (stage1: pull reset low)
  RESET_REG2,  // reset ALERT REGISTERS (stage2: pull reset high)  
  REQUEST_READ, //Request Read from Alert Registers
  READ_REGISTER,//Read from Alert Registers
};

typedef struct {
  uint8_t state; 
  uint8_t i2c_packet[2];
  uint8_t i2c_packet_size;
} hipri_int_state_t; 

static int8_t module (void *state, Message *msg);

static mod_header_t mod_header SOS_MODULE_HEADER =
{
        mod_id: RAGOBOT_HIPRI_INT_PID,
        state_size: sizeof(hipri_int_state_t),
		num_timers : 1,
        num_sub_func: 0,
        num_prov_func: 2,
        module_handler: module,
        funct: {
		  {hipri_int_register, "cCv1", RAGOBOT_HIPRI_INT_PID, HIPRI_INT_REGISTER_FID},
		  {hipri_int_deregister, "cCv1", RAGOBOT_HIPRI_INT_PID, HIPRI_INT_DEREGISTER_FID}
		       },
};

static int8_t module (void *state, Message *msg) 
{
  hipri_int_state_t *s = (hipri_int_state_t*)state;
  uint8_t* alert_reg; //used only when the alert register is read

  switch(msg->type)
	{
	case MSG_INIT:
	  { 
		s->state = INIT;
		ker_timer_init(RAGOBOT_HIPRI_INT_PID, 0, TIMER_ONE_SHOT);
	
		//disable INT6 until all registers are properly set. 
		cbi(EIMSK, 7);
		//Set PE7, the hipri_int, to an input pin
		cbi(DDRE, 7);
		sbi(PORTE, 7); //enable pullup
		
		//generate interrupt on falling edge
		sbi(EICRB, 7);
		cbi(EICRB, 6);

		//enable INT6
		sbi(EIMSK, 7);
		
		//Configure Alert Registers
		s->i2c_packet[0]=0x03; 
		s->i2c_packet[1]=0x3F; //set pin7 and pin6 of Alert Register as output 
		                       //set all others as input
		s->i2c_packet_size = 2;
		//Send Configuration via i2c. If i2c busy, wait and try again.
		if (ker_i2c_send_data(ALERTREG_ADDRESS, s->i2c_packet, s->i2c_packet_size, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
		  {
			ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
		  }
		break;
	  }
	case MSG_I2C_SEND_DONE:
	  {
		if (s->state == INIT)
		  {
			s->state = RESET_REG1;
			s->i2c_packet[0]=0x01; 
			s->i2c_packet[1]=0x7F; //set ALERT REGISTER reset LOW
			s->i2c_packet_size = 2;
			//if i2c busy, then wait and try again later.
			if (ker_i2c_send_data(ALERTREG_ADDRESS, s->i2c_packet, s->i2c_packet_size, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
			  {
				ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
			  }	  
		  } 
		else if (s->state == RESET_REG1)
		  {
			s->state = REQUEST_READ;
			s->i2c_packet[0] = 0x00;
			s->i2c_packet_size = 1;
			if (ker_i2c_send_data(ALERTREG_ADDRESS, s->i2c_packet, s->i2c_packet_size, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
			  {
				ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
			  }
		  }
		else if (s->state == RESET_REG2)
		  {
			s->state = IDLE;
		  }
		else if (s->state == REQUEST_READ)
		  {
			//begin read from register
			s->state = READ_REGISTER;
			if (ker_i2c_read_data(ALERTREG_ADDRESS, 1, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
			  {
				ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
			  }
		  }
		break;
	  }
	  case MSG_I2C_READ_DONE:
		{
		  alert_reg = (uint8_t*) msg->data;
		  //read from register and broadcast alert to the registered modules
		  if ((alert_reg[0] & 0x01) != 0x00)
			{
			  hipri_int_broadcast();
			  //reset alert register
			  s->state = RESET_REG1;
			  s->i2c_packet[0]=0x01; 
			  s->i2c_packet[1]=0x7F; //set ALERT REGISTER reset LOW
			  s->i2c_packet_size = 2;
			  //if i2c busy, then wait and try again later.
			  if (ker_i2c_send_data(ALERTREG_ADDRESS, s->i2c_packet, s->i2c_packet_size, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
				{
				  ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
				}	
			}
		  else
			{
			  s->state = RESET_REG2;
			  s->i2c_packet[0]=0x01; 
			  s->i2c_packet[1]=0xFF; //set ALERT REGISTER reset HI
			  s->i2c_packet_size = 2;
			  //try sending command on i2c. if i2c busy, then wait and try again later
			  if (ker_i2c_send_data(ALERTREG_ADDRESS, s->i2c_packet, s->i2c_packet_size, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
				{
				  ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
				}
			}
		  break;
		}
	  case MSG_TIMER_TIMEOUT:
		{
		  if (s->state == READ_REGISTER) 
			{
			  //try reading from i2c again. if i2c busy, wait and try again.
			  if (ker_i2c_read_data(ALERTREG_ADDRESS, 1, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
				{
				  ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
				}
			}
		  else 
			{
			  //try sending command on i2c again. if i2c busy, then wait and try again later
			  if (ker_i2c_send_data(ALERTREG_ADDRESS, s->i2c_packet, s->i2c_packet_size, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
				{
				  ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
				}
			}
		  break;
		}
	}
  
  return SOS_OK;
}

static void hipri_int_broadcast()
{
  uint8_t i;
  for (i = 0; i < numRegMod; i++) 
	{
	  post_short(registered_modules[i], registered_modules[i], MSG_HIPRI_INT, 0, 0, SOS_MSG_HIGH_PRIORITY);
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//HIPRI_INT INTERRUPT
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SIGNAL(SIG_INTERRUPT7) 
{
  sos_module_t *m = ker_get_module(RAGOBOT_HIPRI_INT_PID);
  hipri_int_state_t *s = (hipri_int_state_t*)m->handler_state;
  
  if ((s->state == IDLE) || (s->state == RESET_REG2))
	{
	  //Interrupt from Alert Register. Read from Alert register 
	  //to find out what caused the alert.
	  s->state = REQUEST_READ;
	  s->i2c_packet[0] = 0x00;
	  s->i2c_packet_size = 1;
	  if (ker_i2c_send_data(ALERTREG_ADDRESS, s->i2c_packet, s->i2c_packet_size, RAGOBOT_HIPRI_INT_PID) != SOS_OK)
		{
		  ker_timer_start(RAGOBOT_HIPRI_INT_PID, 0, BACKOFF_TIME);
		}
	}
} 

static int8_t hipri_int_register(char* proto, uint8_t pid)
{
  if (numRegMod == MAXREGMOD) 
	{
	  return -EINVAL;
	}
  registered_modules[numRegMod] = pid;
  numRegMod += 1;
  return SOS_OK;
}

static int8_t hipri_int_deregister(char* proto, uint8_t pid)
{
  uint8_t i;
  if (numRegMod == 0) 
	{
	  return -EINVAL;
	}
  // Find the pid in the table. If it is found, remove the pid, shrink the 
  // table and return SOS_OK. If not found, return -EINVAL
  for (i = 0; i < numRegMod; i++) 
	{
	  if (registered_modules[i] == pid) 
		{
		  for (i=i+1; i < numRegMod; i++) 
			{
			  registered_modules[i-1] = registered_modules[i];
			}
		  numRegMod--;
		  return SOS_OK;
		}  
	}
  return -EINVAL;
}

#ifndef _MODULE_
mod_header_ptr hipri_int_get_header()
{
  return sos_get_header_address(mod_header);
}
#endif
